hzy_algorithm_pratice
leetcode 1 两数之和
/*两次遍历 一次存储，一次查找*/
vector<int> twoSum(vector<int>& nums, int target) {
	map<int,int> m;
	vector<int> v;
	for(int i=0;i<nums.size();i++)
		m[nums[i]]=i;
	for(int i=0;i<nums.size();i++)
	{
		auto it=m.find(target-nums[i]);
		if(it!=m.end()&&it->second!=i)
		{
			v.push_back(i);
			v.push_back(it->second);
			break;
		}
	}
	return v;
}
/*边存储 边查找*/
vector<int> twoSum(vector<int>& nums, int target) {
	map<int,int> m;
	vector<int> v;
	for(int i=0;i<nums.size();i++)
	{
		auto it=m.find(target-nums[i]);
		if(it!=m.end()&&it->second!=i)
		{
			v.push_back(i);
			v.push_back(it->second);
			break;
		}
		 m[nums[i]]=i;
	}
	return v;
}
leetcode 2 两数相加
/*链表逆序存储 注意进位 两链表长短*/
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
	ListNode* head=new ListNode(-1);//存放结果的链表
	ListNode* h=head;//移动指针
	int sum=0;//每个位的加和结果
	bool carry=false;//进位标志
	while(l1!=NULL||l2!=NULL)
	{
		sum=0;
		if(l1!=NULL)
		{
			sum+=l1->val;
			l1=l1->next;
		}
		if(l2!=NULL)
		{
			sum+=l2->val;
			l2=l2->next;
		}
		if(carry)
			sum++;
		h->next=new ListNode(sum%10);
		h=h->next;
		carry=sum>=10?true:false;
	}
	if(carry)
	{
		h->next=new ListNode(1);
	}
	return head->next;
}
leetcode 5 最长回文子串
/*给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
动态规划思路：从单字符，双字符开始初始化，结合回文数性质首尾相同，中间也是回文数
从小到大 str[i] == str[j] && p[i + 1][j - 1]
*/

#include<iostream>
#include<algorithm>
#include <string>

using namespace std;

bool p[1001][1001] = {false};
int main()
{
	string str;
	cin >> str;
	int len = str.size();
	int start = 0, maxlen = 1;//单字符满足
	for (int i = 0; i < len; i++)
	{
		p[i][i] = true;//dp初始化单字符
		if (i < len - 1 && str[i] == str[i + 1])
		{
			p[i][i + 1] = true;//dp初始化双字符
			start = i;
			maxlen = 2;
		}
	}

	for (int strlen = 3; strlen <= len; strlen++)
	{
		for (int i = 0; i <=len - strlen; i++)
		{
			int j = i + strlen - 1;
			if (str[i] == str[j] && p[i + 1][j - 1])
			{
				p[i][j] = true;//由小到大，全局规划
				maxlen = strlen;
				start = i;
			}
		}
	}
	string ans = "";
	if (maxlen > 0)
	{
		ans = str.substr(start,maxlen);
	}

	cout << ans;
	return 0;
}
leetcode 7 整数反转
/*比较 上下限  取余个数存储*10*/
int reverse(int x) {
	int rev=0;//存放反转后的数
	int pop=0;//存放弹出的数
	while(x!=0)
	{
		pop=x%10;//从右往左依次取数进行反转
		x/=10;
		if(rev>INT_MAX/10 || rev==INT_MAX/10&&pop>7) //判断上限
			return 0;
		if(rev<INT_MIN/10 || rev==INT_MIN/10&&pop<-8) //判断下限
			return 0;
		rev=rev*10+pop;
	}
	return rev;
}
leetcode 9 回文数 （9同7思路）
bool isPalindrome(int x) {
	if(x < 0) 
		return false;
	int param = x;
	long rev = 0;
	int pop = 0;
	while (param != 0) {
		pop = param % 10;
		param /= 10;
		rev = rev * 10 + pop;
		if(rev > INT_MAX || rev < INT_MIN){
			return false;
		}
	}
	return(x == rev);
}

leetcode 19 删除链表的倒数第N个结点
/*给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：
给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.
*/
ListNode* removeNthFromEnd(ListNode* head, int n) {
   
	ListNode* pre=new ListNode(0);//注意头结点删除情况
	pre->next=head;
	
	ListNode* start=pre;
	while(n--){
		start=start->next;
	}
	
	ListNode* end=pre;
	while(start->next){
		start=start->next;
		end=end->next;
	}
	end->next=end->next->next;
	return pre->next;
}

leetcode 21 合并两个有序链表
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
	
	if(l1==NULL&&l2==NULL) return NULL;
	if(l1==NULL) return l2;
	if(l2==NULL) return l1;
	
	ListNode* ph=new ListNode(0);
	ListNode* head=ph;
	while(l1&&l2)
	{
		if(l1->val<=l2->val)
		{
			ph->next=l1;
			ph=l1;
			l1=l1->next;
		}
		else if(l1->val>l2->val)
		{
			ph->next=l2;
			ph=l2;
			l2=l2->next;
		}
	}
	while(l1)
	{
		ph->next=l1;
		ph=l1;
		l1=l1->next;
	}
	while(l2)
	{
		ph->next=l2;
		ph=l2;
		l2=l2->next;
	}
	ph->next=NULL;
	return head->next;
}

leetcode 31 下一个排列
/*算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。*/
void nextPermutation(vector<int>& nums) {

	int i=0, j=nums.size()-1;
	for(i=nums.size()-1; i && nums[i-1]>=nums[i]; --i);
	if(i){
		for(j=nums.size()-1; i<j && nums[i-1]>=nums[j]; --j);
		swap(nums[i-1],nums[j]);
	}
	reverse(nums.begin()+i,nums.end());

}

leetcode 53 最大子序和
/*暴力求解*/
int maxSubArray(vector<int>& nums) {
	if(nums.size()==0) return NULL;
	int max=nums[0];//存最大值 
	int sum=0;//求和
	for(int i=0;i<nums.size();i++)
	{
		sum=0;
		for(int j=i;j<nums.size();j++)
		{
			sum+=nums[j];
			if(sum>max) max=sum;
		}
	}
	return max;
}
/*动态规划 子问题 max(dp[i-1]+nums[i],nums[i]) max中在比较最大值 */
int maxSubArray(vector<int>& nums) {
	
	if(nums.size() == 0) return NULL;
	int *dp=new int[nums.size()];
	dp[0]=nums[0];
	int res=dp[0];
	for(int i = 1; i < nums.size(); ++i)
	{
		dp[i] = max(nums[i], dp[i-1] + nums[i]);
		//if(dp[i-1] + nums[i] < nums[i])
			//head = i;
		res = max(dp[i], res);
	}
	return res;
}

leetcode 55 跳跃游戏
/*给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。*/
bool canJump(vector<int>& nums) {
	if(nums.size()<=0) return false;
	int lastPosition=nums.size()-1;
	for(int i=nums.size()-1;i>=0;i--){
		if(nums[i]+i>=lastPosition)
			lastPosition=i;
	}
	return lastPosition==0;
}

leetcode 56 合并区间 
/*给出一个区间的集合，请合并所有重叠的区间。
排序
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <limits.h>
using namespace std;

struct Interval {
	int start;
	int end;
	Interval() : start(0), end(0) {}
	Interval(int s, int e) : start(s), end(e) {}
}node;

vector<Interval>intervals,res;
bool cmp(Interval a, Interval b)
{
	return a.start < b.start;
}
int main()
{
	int n;
	scanf("%d",&n);
	while (n--)
	{
		scanf("%d,%d",&node.start,&node.end);
		intervals.push_back(node);
	}
	if(intervals.size()==0) 
	{printf("[]"); return 0;}//输入为0，特殊情况

	sort(intervals.begin(),intervals.end(),cmp);//输入顺序可能是乱的

	int s = intervals[0].start;
	int d = intervals[0].end;
	for (int i = 1; i < intervals.size(); i++)
	{
		if (intervals[i].start <= d )
		{
			d = max(intervals[i].end,d);//合并，右边界比较
		}
		else
		{
			res.push_back({s,d});
			s = intervals[i].start;
			d = intervals[i].end;
		}
	}
	res.push_back({ s,d });//注意最后一组只是比较了，没有存储
	for (int i = 0; i < res.size(); i++)
	{
		if (i == 0) printf("[");
		if(i!=res.size()-1)
			printf("[%d,%d],",res[i].start,res[i].end);
		else printf("[%d,%d]]\n", res[i].start, res[i].end);
	}
	return 0;
}

leetcode 62 不同路径
/*排列组合 从m+n-2步中选m-1步右行*/
int uniquePaths(int m, int n) 
{ 
	double ans = 1.0; 
	int min; 
	min = m < n ? m : n; 
	for(int i = 1; i < min; i++) 
	{ 
		ans *= (m + n - 1 - i); 
		ans /= i; 
	} 
	return int(ans); 
} 
leetcode 63 不同路径II
/*动态规划：dp[i][j] 表示 从左上角到 grid[i][j] 的路径数量
  dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i][j-1] + dp[i-1][j];*/
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
	int w = obstacleGrid.size();
	if(w == 0 ) return 0;
	int h = obstacleGrid[0].size();
	long long  dp[w][h];
	dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
	for(int i = 1;i< w;++i){
		dp[i][0]  =  obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0];
	}
	for(int j = 1;j< h;++j){
		dp[0][j]  =  obstacleGrid[0][j] == 1 ? 0 : dp[0][j-1];
	}
	for(int i = 1;i< w;++i){
		for(int j = 1;j<h;++j){
			dp[i][j]  =  obstacleGrid[i][j] == 1 ? 0 : dp[i][j-1] + dp[i-1][j];
		}
	}
	return dp[w-1][h-1];

}

leetcode 64 最小路径和
int minPathSum(vector<vector<int>>& grid) {
	int w=grid.size();
	if(w==0) return 0;
	int h=grid[0].size();
	int dp[w][h];
	dp[0][0]=grid[0][0];
	int i,j;
	for(i=1;i<w;i++)
		dp[i][0]=dp[i-1][0]+grid[i][0];
	for(j=1;j<h;j++)
		dp[0][j]=dp[0][j-1]+grid[0][j];
	
	for(i=1;i<w;i++)
	{
		for(j=1;j<h;j++)
		{
			dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j];
		}
	}
	return dp[w-1][h-1];
}

leetcode 70 爬楼梯
/*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
动态规划：总值就是前两者相加 就是开始走1步或2步方案，一直树状展开
*/
#include <iostream>
#include <algorithm>
#include <limits.h>
using namespace std;

int dp[10001];
int main()
{
	int n;
	cin >> n;
	dp[0] = 1;
	dp[1] = 2;
	for (int i = 2; i <= n; i++)
	{
		dp[i] = dp[i-1]+dp[i-2];
	}
	cout << dp[n-1];
	return 0;
}

leetcode 72 编辑距离
/*给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符

动态规划：
dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数，所以，
当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；
当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示插入操作，dp[i][j-1] 表示删除操作。
*/
int minDistance(string word1, string word2) {
	int n1 = word1.length();
	int n2 = word2.length();
	int dp[n1+1][n2+1];
	
	// 第一行
	for (int j = 0; j <= n2; j++) dp[0][j] = j;
	// 第一列
	for (int i = 0; i <= n1; i++) dp[i][0] = i;

	for (int i = 1; i <= n1; i++) {
		for (int j = 1; j <= n2; j++) {
			if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
			else dp[i][j] = min(min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
		}
	}
	return dp[n1][n2];  
}

leetcode 84 柱状图里最大的矩形
/*暴力 超出时间限制*/
int largestRectangleArea(vector<int>& heights) {
		   
	int res = 0;
	int n = heights.size();
	for(int i=0;i<n;i++)
	{
		int left_i=i;
		int right_i=i;
		while(left_i>=0&& heights[left_i]>=heights[i])
			--left_i;
		while(right_i < n&&heights[right_i] >= heights[i])
			++right_i;
		res=max(res,(right_i-left_i-1)*heights[i]);
	}
	return res;
}
/*优化暴力 边界求边界*/
int largestRectangleArea(vector<int>& heights) {
		   
	if (heights.size()== 0) return 0;
	int n = heights.size();
	int left_i[n];
	int right_i[n];
	left_i[0] = -1;
	right_i[n - 1] = n;
	int res = 0;
	for (int i = 1; i < n; i++) {
		int tmp = i - 1;
		while (tmp >= 0 && heights[tmp] >= heights[i]) tmp = left_i[tmp];
		left_i[i] = tmp;
	}
	for (int i = n - 2; i >= 0; i--) {
		int tmp = i + 1;
		while (tmp < n && heights[tmp] >= heights[i]) tmp = right_i[tmp];
		right_i[i] = tmp;
	}
	for (int i = 0; i < n; i++) res = max(res, (right_i[i] - left_i[i] - 1) * heights[i]);
	return res;  
}
/*单调栈*/
int largestRectangleArea(vector<int>& heights) {
	int n=heights.size();       
	int res = 0;
	stack<int> st;
	int *new_heights=new int[n+2];
	for (int i = 1; i < n + 1; i++) 
		new_heights[i] = heights[i - 1];
	
	for (int i = 0; i < n+2; i++) {
		while (!st.empty() && new_heights[st.top()] > new_heights[i]) {
			int cur = st.top();
			st.pop();
			res = max(res, (i - st.top() - 1) * new_heights[cur]);
		}
		st.push(i);
	}
	return res;  
}

leetcode 86 分隔链表
/*给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。*/
ListNode* partition(ListNode* head, int x) {
	if(head==NULL||head->next==NULL)
		return head;
	ListNode* t1=new ListNode(0);
	ListNode* t2=new ListNode(0);
	ListNode* pt1=t1;
	ListNode* pt2=t2;
	while(head!=NULL)
	{
		if(head->val<x)
		{
			t1->next=head;
			head=head->next;
			t1=t1->next;
			t1->next=NULL;
		}
		else
		{
			t2->next=head;
			head=head->next;
			t2=t2->next;
			t2->next=NULL;
		}
	}
	t1->next=pt2->next;
	return pt1->next;
	
}
leetcode 88 合并两个有序数组
/*给定两个有序整数数组 nums1 和 nums2，
将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。*/
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> num(m+n);
        int i = 0,j = 0,k = 0;
        while(i<m && j<n){
            if(nums1[i] <= nums2[j])
                num[k++] = nums1[i++];
            else
                num[k++] = nums2[j++];
        }
        while(i < m) num[k++] = nums1[i++];
        while(j < n) num[k++] = nums2[j++];
        nums1.assign(num.begin(),num.end());//vector的拷贝nums1.swap(num)也可以
    }
};
leetcode 92 部分反转链表
ListNode* reverseBetween(ListNode* head, int m, int n) {
	if(m<1||n<1||head==NULL||head->next==NULL||m==n)
		return head;
	ListNode* t1=NULL;
	if(m==1){
		t1=new ListNode(INT_MAX);
		t1->next=head;
	}
	ListNode* t2=head;
	for(int i=1;i<m;i++)
	{
		t1=t2;
		t2=t2->next;
	}
	ListNode* last=t2;
	for(int i=0;i<n-m;i++)
	{
		last=last->next;
	}
	last=last->next;
	ListNode* cur=NULL;
	ListNode* next=NULL;
	cur=t1->next->next;
	t1->next->next=last;
	while(cur!=last)
	{
		next=cur->next;
		cur->next=t1->next;
		t1->next=cur;
		cur=next;
	}
	if(t1->val==INT_MAX)
	{
		ListNode* ret=t1->next;
		delete t1;
		return ret;
	}
	
	return head;
}

leetcode 102

leetcode 136 只出现一次的数字
/*给定一个非空整数数组，除了某个元素只出现一次以外，
其余每个元素均出现两次。找出那个只出现了一次的元素。*/
class Solution {
public:
    map<int,int>p;
    int singleNumber(vector<int>& nums) {
        int len=nums.size();
        int save_i=0;
        
        for(int i=0;i<len;i++)
        {
            p[nums[i]]++;
            save_i+=nums[i];
            if(p[nums[i]]==2)//其余每个元素均出现两次。
            {
                save_i-=nums[i]*2;
                p[nums[i]]=0;
            }
        }
        return save_i;
    }
};

leetcode 141 环形链表 
/*快慢指针相遇就是环存在*/
bool hasCycle(ListNode *head) {
	if(head==NULL||head->next==NULL||head->next->next==NULL) return false;
	ListNode* fast=head->next->next;
	ListNode* slow=head->next;
	while(fast!=slow)
	{
		if(fast==NULL||fast->next==NULL)
			return false;
		fast=fast->next->next;
		slow=slow->next;
	}
	return true;
}

leetcode 142 环形链表II
/*快慢指针 在将快指针回到开头与慢指针一步一步相遇就是环入口*/
ListNode *detectCycle(ListNode *head) {
	if(head==NULL||head->next==NULL||head->next->next==NULL) return NULL;
	ListNode* fast=head->next->next;
	ListNode* slow=head->next;
	while(fast!=slow)
	{
		if(fast==NULL||fast->next==NULL)
			return NULL;
		fast=fast->next->next;
		slow=slow->next;
	}
	fast=head;
	while(fast!=slow)
	{
		fast=fast->next;
		slow=slow->next;
	}
	return fast;
}

leetcode 143 重排链表
/*给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…   要记得STL容器的利用*/
void reorderList(ListNode* head) {
	if(head==NULL||head->next==NULL||head->next->next==NULL)
		return ;
	vector<ListNode*>v;
	ListNode* start=head;
	while(start)
	{
		v.push_back(start);
		start=start->next;
	}
	
	int left=0;
	int right=v.size()-1;
	while(left<right)
	{
		v[left]->next=v[right];
		v[right--]->next=v[++left];
	}
	v[left]->next=NULL;
		
}

leetcode 160 相交链表
/*编写一个程序，找到两个单链表相交的起始节点。*/
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	if(headA==NULL||headB==NULL) return NULL;
	int len1=0,len2=0;
	ListNode *phead1=headA,*phead2=headB;
	while(phead1){
		len1++;
		phead1=phead1->next;
	}
	while(phead2){
		len2++;
		phead2=phead2->next;
	}
	phead1=headA;
	phead2=headB;
	if(len1>len2){
		for(int i=0;i<(len1-len2);i++)
			phead1=phead1->next;
	}
	else{
		for(int i=0;i<(len2-len1);i++)
			phead2=phead2->next;
	}
	while(phead1){
		if(phead1==phead2) return phead1;
		phead1=phead1->next;
		phead2=phead2->next;
	}
	return NULL;
}

leetcode 169 求众数
/*给定一个大小为 n 的数组，找到其中的众数。
众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。取下整数
你可以假设数组是非空的，并且给定的数组总是存在众数。*/
class Solution {
public:
    map<int,int>p;
    int majorityElement(vector<int>& nums) {
        int len=nums.size();
        int i;
        for(i=0;i<len;i++)
        {
            p[nums[i]]++;
            if(p[nums[i]]>len/2)
            {   
               break;
            }
        }
         return nums[i];
    }
};
leetcode 200 岛屿的个数
/*给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。
一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。
你可以假设网格的四个边均被水包围。
DFS
*/
#include <iostream>
#include <algorithm>
#include <vector>
#include <limits.h>
using namespace std;

int n, m;
vector<vector<char>>grid;
vector<vector<bool>>visited;
int d[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };//四个边

bool inArea(int x, int y)
{
	return (x >= 0 && x < n&&y >= 0 && y < m);
}

void dfs(vector<vector<char>>& grid, int x, int y) {

	visited[x][y] = true;
	for (int i = 0; i < 4; i++) {
		int newx = x + d[i][0];
		int newy = y + d[i][1];
		if (inArea(newx, newy) && !visited[newx][newy] && grid[newx][newy] == '1')
			dfs(grid, newx, newy);
	}

	return;
}

int main()
{
	int res=0;
	scanf("%d%d",&n,&m);
	getchar();//捕捉回车
	if (n == 0 || m == 0)
	{
		cout << res;
		return 0;
	}
	grid.resize(n);
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			char value;
			scanf("%c",&value);
			grid[i].push_back(value);
		}
	}
	for (int i = 0; i < n; i++)
		visited.push_back(vector<bool>(m, false));//行

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (grid[i][j] == '1' && !visited[i][j])
			{
				dfs(grid,i,j);
				res++;
			}
		}
	}
	cout << res;
	return 0;
}
leetcode 206 反转链表逆序
ListNode* reverseList(ListNode* head) {
	if(head==NULL||head->next==NULL) 
		return head;
	ListNode* phead=new ListNode(0);
	phead->next=head;
	ListNode* cur=NULL;
	cur=phead->next->next;
	phead->next->next=NULL;
	ListNode* next=NULL;
	while(cur!=NULL){
		next=cur->next;
		cur->next=phead->next;
		phead->next=cur;
		cur=next;
	}
	return phead->next;
}

leetcode 225 用队列实现栈
class MyStack {
public:
    /** Initialize your data structure here. */
    queue<int> q;
    MyStack() {
        
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
        for(int i=0;i<q.size()-1;i++){
            q.push(q.front());
            q.pop();
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int t=q.front();
        q.pop();
        return t;
    }
    
    /** Get the top element. */
    int top() {
        return q.front();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};

leetcode 232 用栈实现队列
class MyQueue {
public:
    /** Initialize your data structure here. */
    stack<int> a;
    stack<int> b;
    MyQueue() {}
    /** Push element x to the back of queue. */
    void push(int x) {
        a.push(x);
    }
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(b.empty()) {
            while(!a.empty()){
                b.push(a.top());
                a.pop();
            }
        }
        int t=b.top();
        b.pop();
        return t;
    }
    /** Get the front element. */
    int peek() {
        if(b.empty()) {
            while(!a.empty()){
                b.push(a.top());
                a.pop();
            }
        }
        return b.top();     
    }
    /** Returns whether the queue is empty. */
    bool empty() {
        return a.empty()&&b.empty();
    }
};

leetcode 240 搜索二维矩阵
/*编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
每行的元素从左到右升序排列。
每列的元素从上到下升序排列。*/
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false;
        if (target < matrix[0][0] || target > matrix.back().back()) return false;
        int x = matrix.size() - 1, y = 0;
        while (true) {
            if (matrix[x][y] > target) --x;
            else if (matrix[x][y] < target) ++y;
            else return true;
            if (x < 0 || y >= matrix[0].size()) break;
        }
        return false;
    }
};

leetcode 300 最长上升子序列
//时间复杂度O(n^2)
int lengthOfLIS(vector<int>& nums) {
	int len=nums.size();
	int *a=new int[len];
	int ss=0;
	for(int i=0;i<len;i++){
		a[i]=1;
		for(int j=i-1;j>=0;j--){
			if(nums[j]<nums[i])
				a[i]=max((a[j]+1),a[i]);
		}
	}
	for(int i=0;i<len;i++)
		ss=max(ss,a[i]);
	return ss;
}
//时间复杂度O(nlogn)
int lengthOfLIS(vector<int>& nums) {
	int length=nums.size();
	int *a=new int[length];
	int len=0;
	for(int i=0;i<length;i++){
		int low=0;
		int high=len;
		while(low<high){
			int mid=(low+high)/2;
			if(a[mid]<nums[i]){
				low=mid+1;
			}
			else high=mid;
		}
		a[low]=nums[i];
		if(low==len) len++;
	}
	return len;
}

leetcode 322 零钱兑换
/*给定不同面额的硬币 coins 和一个总金额 amount。
编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。
动态规划思路：从单硬币能凑成的数值开始，向上推导
当前硬币数额小于当前价值，且当前价值减去当前硬币值的数额在之前被凑到，可继续判断
*/

#include<iostream>
#include<algorithm>
#include <string>
#include <vector>
#include <limits.h>
using namespace std;
int dp[10001];
vector<int>coins;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int num; cin >> num;
		coins.push_back(num);
	}
	int amount;
	cin >> amount;
	dp[0] = 0;//初始化
	for (int i = 1; i <= amount; i++)
	{
		dp[i] = INT_MAX;//初始化
		for (int k : coins)
		{//从单个硬币面额能凑到的数值用量最少为基础 向上推导
			if (i >= k && dp[i - k] != INT_MAX) // 当前价值大于当前硬币面额的数值，当前价值减去当前硬币面额的数值能凑到继续判断
				dp[i] = min(dp[i-k]+1,dp[i]);//当前价值减去当前硬币面额最少的用量+1
		}
	}
	if (dp[amount] >= INT_MAX)
		cout << -1;
	else
		cout << dp[amount] ;//若amount==0,输出dp[0]=0
	return 0;
}

leetcode 328 奇偶链表
/*两个指针 一奇数一偶数 记得最后奇偶相连*/
ListNode* oddEvenList(ListNode* head) {
	if(head==NULL||head->next==NULL||head->next->next==NULL) return head;
	ListNode* jh=head;
	ListNode* n1=jh;
	ListNode* oh=head->next;
	ListNode* n2=oh;
	int i=1;
	head=head->next->next;
	while(head)
	{
		if(i%2==1)
		{
			jh->next=head;
			jh=head;
			head=head->next;
		}
		if(i%2==0)
		{
			oh->next=head;
			oh=head;
			head=head->next;
		}
		i++;
	}
	oh->next=NULL;
	jh->next=n2;
	return n1;
}

leetcode 367 有效的完全平方数
/*思路:不用sqrt 1+3+5+...(2n-1)=n^2*/
bool isPerfectSquare(int num) {
	int sum=1;
	while(num>0)
	{
		num-=sum;
		sum+=2;
	}
	return num==0;
}

leetcode 371 两数相加
/*思路1：不用+-，用++，--*/
int getSum(int a, int b) {
	if(a>0){
		while(a>0){
			a--;
			b++;
		}
	}
	else{
		while(a<0){
			a++;
			b--;
		}
	}
	return b;
}
/*思路2： a ^ b是无进位的相加； a&b<<1得到每一位的进位；
让无进位相加的结果与进位不断的异或， 直到进位为0；*/
int getSum(int a, int b) {
	while(b){
		int sum=a^b;
		int carry=(unsigned int)(a&b)<<1;
		a=sum;
		b=carry;
	}
	return a;
}

leetcode 378 有序矩阵第K小元素
// O(nlogn)
int kthSmallest(vector<vector<int>>& matrix, int k) {
	int l = matrix[0][0], r = matrix.back().back();
	int row=matrix.size();
	int column=matrix[0].size();
	while(l <= r){
		int mid = (r-l)/2 + l;
		int count = 0;
		for (int i = 0; i < row; i++){
			for (int j = 0; j < column; j++){
				if(matrix[i][j] <= mid)
					count++;
			}
		}
		if (count < k) l = mid + 1;
		else r = mid - 1;
	}
	return l;
}

    // O(nlogn)
int kthSmallest(vector<vector<int>>& matrix, int k) {
	int n = matrix.size();
	int m = matrix[0].size();
	int low = matrix[0][0];
	int high = matrix[n-1][m-1];
	int count = 0;
	while (low < high) {
		int mid = low + (high - low)/2;
		int i = 0;
		int j = m-1;
		/* 二分搜索, 从左下角开始与 mid 进行比较 */
		count = 0;
		while (j >= 0 && i < n) {   /* leetcode: 240 */
			if(mid < matrix[i][j]) j--;
			else {
				count += (j+1);
				i++;
			}
		}
		if(count >= k) high = mid;
		else low = mid+1;
	}
	return low;
}

leetcode 440 字典序的第k个数
/*输入:n: 13   k: 2 输出:10
解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
*/
int findKthNumber(int n, int k) {
	int cur = 1;
	--k;//初始化为cur = 1，k需要自减1
	while (k > 0) {
		long long step = 0, first = cur, last = cur + 1;
		//统计这棵子树下所有节点数（step）
		while (first <= n) {
			step += min((long long)n + 1, last) - first;//不能超过n的值，并不是所有节点都有十个子节点
			first *= 10;
			last *= 10;
		}
		if (step <= k) {//不在子树中
			++cur;
			k -= step;
		} 
		else {//在子树中，进入子树
			cur *= 10;
			--k; 
		}
	}
	return cur;
}

leetcode 486 预测赢家
/*给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，
随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。
每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。
直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化

动态规划思路：从单,双区间数取最大值初始化，再向上推导三区间数。。。n-1区间数
与暴力递归，相似，只是省去函数递归调用的开销
*/

#include<iostream>
#include<algorithm>
#include <string>
#include <vector>
#include <limits.h>
using namespace std;

vector<int>nums;
//递归调用
int f(vector<int>& nums, int i, int j)
{
	if (i == j) return nums[i];
	if (j == i + 1) return max(nums[i], nums[j]);//玩家原则选大分
	return max( 
		nums[i] + min(f(nums, i + 1, j - 1), f(nums, i + 2, j)),
		nums[j] + min(f(nums, i + 1, j - 1), f(nums, i, j - 2)) );
}
int dp[21][21];
int main()
{
	int n,sum=0;
	cin >> n;
	while (n--)
	{
		int num; cin >> num;
		sum += num;
		nums.push_back(num);
	}
	//递归调用
	//int first = f(nums,0,nums.size()-1);
	//cout << (first >= (sum - first));
	//动态规划
	int len = nums.size();
	for (int i=0;i<len;i++)
		dp[i][i] = nums[i];//单区间数初始化
	for (int i = 1; i < len; i++)
		dp[i - 1][i] = max(dp[i-1][i-1],dp[i][i]);//双区间数初始化

	for (int i = 2; i < len; i++)
	{
		//从短区间数到长区间数，推导
		for (int j = 0; j < len - i; j++)
		{
			dp[j][j + i] =
				max(nums[j] + min(dp[j + 1][i + j - 1], dp[j + 2][i + j]),
					nums[i + j] + min(dp[j][i + j - 2], dp[j + 1][i + j - 1]));
		}
	}
	cout << (dp[0][len-1]>=(sum- dp[0][len - 1]));
	return 0;
	
}

leecode 567 字符串排列
/*给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。*/
bool checkInclusion(string s1, string s2) {
	int len1=s1.size();
	int len2=s2.size();
	vector<int> v1(26,0);
	vector<int> v2(26,0);
	if(len1>len2) return false;
	if(len1==0) return true;
	
	for(int i=0;i<len1;i++){
		v1[s1[i]-'a']++;
		v2[s2[i]-'a']++;
	}
	if(v1==v2) return true;
	
	for(int i=0;i+len1<len2;i++){
		v2[s2[i]-'a']--;//移动头
		v2[s2[i+len1]-'a']++;//移动尾
		
		if(v1==v2) return true;
	}
	return false;
}

leetcode 696 计数二进制子串
/*思路： 只有0和1的字符串 0011 01 10 1100 才算
  记录连续0、1的数量，取小相加*/
int countBinarySubstrings(string s) {
	int len=s.size();
	int *group=new int[len];
	group[0]=1;
	int index=0;
	for(int i=1;i<len;i++)
	{
		if(s[i]!=s[i-1])
		{
			group[++index]=1;
		}
		else{
			group[index]++;
		}
	}
	int res=0;
	for(int i=0;i<index;i++)
	{
		res=res+min(group[i],group[i+1]);
	}
	return res;
}

leetcode 697 数组的度(数组出现的最大频度值)
/*求解数组中满足最大频度值的最短子序列长度
思路：求出最大频度，存储最大频度的元素
去遍历满足最大频度的元素的跨度比较得出最小值*/
int findShortestSubArray(vector<int>& nums) {

	map<int, int>m;
	vector<int>n;
	int maxp = 0;
	int begin,end;
	int minlen = nums.size();
	for (int i : nums) {
		m[i]++;
		if (m[i] > maxp) maxp = m[i];
	}
	for (auto i : m) {
		if (i.second == maxp) n.push_back(i.first);//记录出现最大频度的数
	}
	for (int N : n) {
		for (int j=0;j<nums.size();j++)
		{
			if (nums[j] == N) { begin = j; break; }
		}
		for (int j =nums.size()-1; j>=0; j--)
		{
			if (nums[j] == N) { end = j; break; }
		}
		if (end - begin + 1 < minlen) minlen = (end-begin+1);
	}
	return minlen;
}
leetdode 725 分隔链表 
/*给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。
每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。
这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。*/
vector<ListNode*> splitListToParts(ListNode* root, int k) {
	
	vector<ListNode*>ret;
	int len=0;
	ListNode* p=root;
	while(p!=NULL)
	{
		len++;
		p=p->next;
	}
	int n=len/k;
	int a=len%k;
	p=root;
	
	while(p!=NULL)
	{
		ret.push_back(p);
		int f=(n-1)+(a>0?1:0);
		a--;
		for(int i=0;i<f;i++)
		{
			p=p->next;
		}
		if(p==NULL)
			continue;
		
		ListNode* next=p->next;
		p->next=NULL;
		p=next;
	}
	while(ret.size()<k)
		ret.push_back(NULL);
	return ret;
}

leetcode 754 
/*
在一根无限长的数轴上，你站在0的位置。终点在target的位置。
每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。
返回到达终点需要的最小移动次数。

很简单，只要sum比|target|大，而且差值为偶数就可以了； 
假设a为正向移动步数，b为负向移动步数，有a-b==|target|，sum==a+b； 则有sum-|target| == 2b;
*/
int reachNumber(int target) {
	target=abs(target);
	int sum=0;
	int res=1;
	while(target>sum||(target-sum)%2!=0){
		sum+=res;
		res++;
	}
	return res-1;
}

leetcode 984 不含AAA和BBB的字符串
/*给定两个整数 A 和 B，返回任意字符串 S，要求满足：
S 的长度为 A + B，且正好包含 A 个 'a' 字母与 B 个 'b' 字母；
子串 'aaa' 没有出现在 S 中；
子串 'bbb' 没有出现在 S 中。
3个 2个
*/
#include<iostream>
#include<algorithm>
#include <string>

using namespace std;

int main()
{
	int A, B;
	scanf("%d %d",&A,&B);
	char a = 'a', b = 'b';
	if (A < B)
	{
		swap(A,B);
		swap(a, b);
	}
	string str = "";
	while (A > 0 || B > 0)
	{
		if (A > 0)
		{
			str.push_back(a);
			A--;
		}
		if (A > B)
		{
			str.push_back(a);
			A--;
		}
		if (B > 0)
		{
			str.push_back(b);
			B--;
		}
	}
	cout << str;
	return 0;
}

leetcode 887 鸡蛋掉落
/*你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
动态规划 K个蛋m步能确定几层*/
class Solution {
public:
    int superEggDrop(int K, int N) {
        if(K==0) return 0;
        if(K==1) return N;
        int dp[N+2][K+2];
        memset(dp,0,sizeof(dp));
        dp[0][0]=0;
        for(int i=1;i<=N;++i)
        {
            dp[i][0]=0;
            for(int j=1;j<=K;++j)
            {
                dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+1;
                if(dp[i][j]>=N)
                    return i;
            }
        }
        return N; 
    }
};

//计算排列组合C(n,k)=C(n-1,k-1)+C(n-1,k)
int c[15][15] = { 0 };
void init()
{
	c[0][0] = 1;
	for (int i = 1; i < 15; ++i)
	{
		c[i][0] = 1;
		for (int j = 1; j < 15; ++j)
		{
			c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
		}
	}
}

leetcode 1041 困于环中的机器人
/*思路 遍历命令 只有方向向前和回到原点成功*/
bool isRobotBounded(string instructions) {
	int x = 0, y = 0, i = 0;
	int dir[][2] = { {0,1},{1,0},{0,-1},{-1,0} };
	do {
		for (char c : instructions)
		{
			if (c == 'G')
			{
				x += dir[i][0];
				y += dir[i][1];
			}
			else if (c == 'L')
			{
				i++;
				i %= 4;
			}
			else
			{
				i += 4;//防止0开始--
				i--;
				i %= 4;
			}
		}
	} while (i != 0);
	if (x == 0 && y == 0) return true;
	return false;
}

leetcode 1042 不邻接植花
/*思路 先建图，遍历结点着色*/
vector<int> gardenNoAdj(int N, vector<vector<int>>& paths) {
	vector<int> ret(N + 1, 0);
	map<int, set<int> > map_value;

	for (int i = 0; i < paths.size(); i++)
	{
		map_value[paths[i][0]].insert(paths[i][1]);
		map_value[paths[i][1]].insert(paths[i][0]);
	}
	for (int i = 1; i <= N; i++)
	{
		set<int> exist;
		for (set<int>::iterator it = map_value[i].begin(); it != map_value[i].end(); it++)
		{
			if (ret[*it] != 0)
			{
				exist.insert(ret[*it]);
			}
		}
		for (int j = 1; j <= 4; j++)
		{
			if (exist.find(j) == exist.end())
			{
				ret[i] = j;
				break;
			}
		}

	}
	vector<int> test;
	test.insert(test.begin(), ret.begin() + 1, ret.end());
	return test;
}

leetcode 1043 分隔数组以得到最大和
/*思路：简单DP。dp[i]表示分割完前i个数，最大值是多少。
j表示当前段的长度[1,K]。
假设我们知道[i-j,i]这一段的最大值curMax，那么dp[i]可以从dp[i-j]推过来。
 dp[i] = max(dp[i],(i>=K?dp[i-j]:0)+curMax*j);
curMax又可以通过遍历j的时候来更新。*/
class Solution {
public:
    int maxSumAfterPartitioning(vector<int>& A, int K) {
        int n = A.size();
        vector<int> dp(n,0);
        
        
        for(int i=0;i<A.size();i++)
        {
            int curMax = 0;
            for(int j=1;j<=K && i-j+1>=0;j++)
            {
                curMax = max(curMax,A[i-j+1]);
                dp[i] = max(dp[i],(i>=K?dp[i-j]:0)+curMax*j);
            }
        }
        return dp[n-1];
    }

};

leetcode 1046 Last Stone Weight
/*每次选最重的两个 priority_queue*/
int lastStoneWeight(vector<int>& stones) {
	priority_queue< int > q;
	for (int s : stones)
		q.push(s);
	while (q.size() > 1)
	{
		int n1 = q.top();
		q.pop();
		int n2 = q.top();
		q.pop();
		int res = abs(n1 - n2);
		q.push(res);
	}
	return q.top();
}

leetcode 1047 删除字符串里所有重复项
/*两个相邻的重复字符删除，栈思路，比较字符与栈顶元素，相同删除*/
string removeDuplicates(string S) {
	stack<char> st;
	for (char str : S) {
		if (st.empty())
			st.push(str);
		else {
			if (str == st.top())
				st.pop();
			else
				st.push(str);
		}
	}
	string res = "";
	while (!st.empty())
	{
		res.push_back(st.top());
		st.pop();
	}
	reverse(res.begin(),res.end());
	return res;
}

leetcode 1049 Last Stone Weight II
/*思路: 分成两堆i,sum-i,使i接近于sum/2,即差最小
   使用dp来求组成i质量堆最大能有多少*/
class Solution {
public:
    int dp[8000];
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int i = 0 ; i < stones.size(); i++)
            sum += stones[i];
        int ans = sum >> 1;
        for(int i = 0; i < stones.size(); i++){
            for(int j = ans; j >= stones[i]; j--){
                dp[j] = max(dp[j], dp[j-stones[i]]+stones[i]);
            }
        }
        return abs(sum - dp[ans] - dp[ans]);
    }
};
